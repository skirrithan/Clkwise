{
  "id": "violation#0",
  "input": {
    "clock": "sys_clk@100.0MHz (10.0ns)",
    "overview": {
      "wns_ns": -1.882,
      "tns_ns": -63.121,
      "violations": 20
    },
    "sdc_gaps": [
      "Missing set_input_delay on at least one input; verify external timing model."
    ],
    "issues": [
      {
        "path_kind": "reg->reg",
        "signal_group": "y_reg[*]",
        "worst_bit": 55,
        "worst_slack_ns": -1.882,
        "dominant_delay": "logic",
        "skew_character": "negative_destination_skew",
        "evidence": {
          "data_path_ns": 14.535,
          "logic_ns": 9.671,
          "route_ns": 4.863,
          "levels_of_logic": 21,
          "clock_skew_ns": 3.624,
          "output_delay_ns": null,
          "dcd_ns": 3.624,
          "scd_ns": 0.0,
          "cpr_ns": 0.0,
          "clock_uncertainty_ns": 0.035,
          "tsj_ns": 0.071,
          "tij_ns": 0.0,
          "dj_ns": 0.0,
          "pe_ns": 0.0,
          "required_time_ns": null,
          "arrival_time_ns": null,
          "io_primitive": null,
          "io_site": null,
          "src_slice": null,
          "clock_net_fanout_max": null,
          "clock_net_delay_ns_total": null
        },
        "root_cause": "Deep combinational logic on REG->REG path with high logic.",
        "where_in_code": {
          "dest_port": "y_reg[[63:44]",
          "src_ff_regex": "y_reg\\[(\\d+)\\]"
        },
        "fix_hints": [
          "Insert a pipeline stage (retime) to split combinational depth.",
          "Duplicate high-fanout registers to reduce net delay; add MAX_FANOUT or phys_opt_design -dup_registers.",
          "Constrain/floorplan critical cells closer together; pblock and keep hierarchy."
        ]
      }
    ]
  },
  "result": {
    "summary": {
      "clock_name": "sys_clk",
      "period_ns": 10.0,
      "wns_ns": -1.882,
      "path_kind": "reg->reg",
      "signal_group": "y_reg[*]",
      "root_cause": "Deep combinational logic chain across multiple multiplications and additions on a single clock edge causing negative slack."
    },
    "fixes": [
      {
        "id": "F1",
        "title": "Insert pipeline after first‑level multiplications",
        "rationale": "Breaks the long combinational path by registering mul1 and mul2 results before they are used downstream.",
        "where": {
          "file": "top.sv",
          "anchor_regex": "logic \\[63:0\\] mul1, mul2;",
          "ports_touched": [],
          "signals_new": [
            "mul1_reg",
            "mul2_reg"
          ]
        },
        "verilog_patch": {
          "kind": "insert_block",
          "after_regex": "logic \\[63:0\\] mul1, mul2;",
          "block": "\n  // Pipeline registers after first‑level multiplications\n  logic [63:0] mul1_reg, mul2_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      mul1_reg <= '0;\n      mul2_reg <= '0;\n    end else begin\n      mul1_reg <= mul1;\n      mul2_reg <= mul2;\n    end\n  end\n"
        },
        "latency_impact_cycles": 1
      },
      {
        "id": "F2",
        "title": "Pipeline second‑level multiplication",
        "rationale": "Registers the result of mul3 which depends on mul1_reg, further shortening the combinational depth.",
        "where": {
          "file": "top.sv",
          "anchor_regex": "logic \\[63:0\\] mul3;",
          "ports_touched": [],
          "signals_new": [
            "mul3_reg"
          ]
        },
        "verilog_patch": {
          "kind": "insert_block",
          "after_regex": "logic \\[63:0\\] mul3;",
          "block": "\n  // Register mul3 result\n  logic [63:0] mul3_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      mul3_reg <= '0;\n    else\n      mul3_reg <= mul3;\n  end\n"
        },
        "latency_impact_cycles": 1
      },
      {
        "id": "F3",
        "title": "Pipeline first addition (sum1)",
        "rationale": "Separates sum1 from its inputs mul1_reg and mul2_reg, reducing logic levels per clock.",
        "where": {
          "file": "top.sv",
          "anchor_regex": "logic \\[63:0\\] sum1;",
          "ports_touched": [],
          "signals_new": [
            "sum1_reg"
          ]
        },
        "verilog_patch": {
          "kind": "insert_block",
          "after_regex": "logic \\[63:0\\] sum1;",
          "block": "\n  // Register sum1 result\n  logic [63:0] sum1_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      sum1_reg <= '0;\n    else\n      sum1_reg <= sum1;\n  end\n"
        },
        "latency_impact_cycles": 1
      },
      {
        "id": "F4",
        "title": "Pipeline second addition (sum2)",
        "rationale": "Registers sum2 which combines sum1_reg and mul3_reg, cutting the remaining combinational path.",
        "where": {
          "file": "top.sv",
          "anchor_regex": "logic \\[63:0\\] sum2;",
          "ports_touched": [],
          "signals_new": [
            "sum2_reg"
          ]
        },
        "verilog_patch": {
          "kind": "insert_block",
          "after_regex": "logic \\[63:0\\] sum2;",
          "block": "\n  // Register sum2 result\n  logic [63:0] sum2_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      sum2_reg <= '0;\n    else\n      sum2_reg <= sum2;\n  end\n"
        },
        "latency_impact_cycles": 1
      },
      {
        "id": "F5",
        "title": "Pipeline final conditional result",
        "rationale": "Registers the output of the conditional arithmetic before it enters the output pipeline, ensuring no long combinational chain reaches the output registers.",
        "where": {
          "file": "top.sv",
          "anchor_regex": "logic \\[63:0\\] final_result;",
          "ports_touched": [],
          "signals_new": [
            "final_result_reg"
          ]
        },
        "verilog_patch": {
          "kind": "insert_block",
          "after_regex": "logic \\[63:0\\] final_result;",
          "block": "\n  // Register final_result\n  logic [63:0] final_result_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      final_result_reg <= '0;\n    else\n      final_result_reg <= final_result;\n  end\n"
        },
        "latency_impact_cycles": 1
      },
      {
        "id": "F6",
        "title": "Add IOB attribute to output register and keep existing three‑stage output pipeline",
        "rationale": "Improves timing for the final output path and retains a deep output pipeline for additional timing margin.",
        "where": {
          "file": "top.sv",
          "anchor_regex": "always_ff @\\(posedge clk or negedge rst_n\\) begin\\n    if \\(!rst_n\\)\\n      y <= '0;",
          "ports_touched": [],
          "signals_new": [
            "y_reg"
          ]
        },
        "verilog_patch": {
          "kind": "replace_regex",
          "before_regex": "always_ff @\\(posedge clk or negedge rst_n\\) begin\\n    if \\(!rst_n\\)\\n      y <= '0;\\n    else\\n      y <= pipe3;\\n  end",
          "block": "(* IOB=\"TRUE\" *) logic [63:0] y_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      y_reg <= '0;\n    else\n      y_reg <= pipe3;\n  end\n\n  assign y = y_reg;"
        },
        "latency_impact_cycles": 0
      }
    ],
    "artifacts": {
      "top_sv": {
        "path": "top.sv",
        "language": "verilog",
        "encoding": "utf-8",
        "content": "module top(\n    input  logic        clk,\n    input  logic        rst_n,\n    input  logic [31:0] a, b, c, d, e,\n    output logic [63:0] y\n);\n\n  // Stage 1: first level multiplications\n  logic [63:0] mul1, mul2;\n  assign mul1 = a * b;\n  assign mul2 = c * d;\n\n  // Pipeline registers after first‑level multiplications\n  logic [63:0] mul1_reg, mul2_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      mul1_reg <= '0;\n      mul2_reg <= '0;\n    end else begin\n      mul1_reg <= mul1;\n      mul2_reg <= mul2;\n    end\n  end\n\n  // Stage 2: second multiplication using registered mul1\n  logic [63:0] mul3;\n  assign mul3 = mul1_reg[31:0] * e;\n\n  // Register mul3 result\n  logic [63:0] mul3_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      mul3_reg <= '0;\n    else\n      mul3_reg <= mul3;\n  end\n\n  // Stage 3: sum1 = mul1_reg + mul2_reg\n  logic [63:0] sum1;\n  assign sum1 = mul1_reg + mul2_reg;\n\n  // Register sum1 result\n  logic [63:0] sum1_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      sum1_reg <= '0;\n    else\n      sum1_reg <= sum1;\n  end\n\n  // Stage 4: sum2 = sum1_reg + mul3_reg\n  logic [63:0] sum2;\n  assign sum2 = sum1_reg + mul3_reg;\n\n  // Register sum2 result\n  logic [63:0] sum2_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      sum2_reg <= '0;\n    else\n      sum2_reg <= sum2;\n  end\n\n  // Stage 5: final_result conditional\n  logic [63:0] final_result;\n  always_comb begin\n    if (|a)\n      final_result = sum2_reg + mul1_reg;\n    else\n      final_result = sum2_reg - mul2_reg;\n  end\n\n  // Register final_result\n  logic [63:0] final_result_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      final_result_reg <= '0;\n    else\n      final_result_reg <= final_result;\n  end\n\n  // Output pipeline stages (3 deep)\n  logic [63:0] pipe1, pipe2, pipe3;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      pipe1 <= '0;\n      pipe2 <= '0;\n      pipe3 <= '0;\n    end else begin\n      pipe1 <= final_result_reg;\n      pipe2 <= pipe1;\n      pipe3 <= pipe2;\n    end\n  end\n\n  // Output register with IOB attribute\n  (* IOB=\"TRUE\" *) logic [63:0] y_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      y_reg <= '0;\n    else\n      y_reg <= pipe3;\n  end\n\n  assign y = y_reg;\n\nendmodule\n",
        "ui": {
          "text": "module top(\n    input  logic        clk,\n    input  logic        rst_n,\n    input  logic [31:0] a, b, c, d, e,\n    output logic [63:0] y\n);\n\n  // Stage 1: first level multiplications\n  logic [63:0] mul1, mul2;\n  assign mul1 = a * b;\n  assign mul2 = c * d;\n\n  // Pipeline registers after first‑level multiplications\n  logic [63:0] mul1_reg, mul2_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      mul1_reg <= '0;\n      mul2_reg <= '0;\n    end else begin\n      mul1_reg <= mul1;\n      mul2_reg <= mul2;\n    end\n  end\n\n  // Stage 2: second multiplication using registered mul1\n  logic [63:0] mul3;\n  assign mul3 = mul1_reg[31:0] * e;\n\n  // Register mul3 result\n  logic [63:0] mul3_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      mul3_reg <= '0;\n    else\n      mul3_reg <= mul3;\n  end\n\n  // Stage 3: sum1 = mul1_reg + mul2_reg\n  logic [63:0] sum1;\n  assign sum1 = mul1_reg + mul2_reg;\n\n  // Register sum1 result\n  logic [63:0] sum1_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      sum1_reg <= '0;\n    else\n      sum1_reg <= sum1;\n  end\n\n  // Stage 4: sum2 = sum1_reg + mul3_reg\n  logic [63:0] sum2;\n  assign sum2 = sum1_reg + mul3_reg;\n\n  // Register sum2 result\n  logic [63:0] sum2_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      sum2_reg <= '0;\n    else\n      sum2_reg <= sum2;\n  end\n\n  // Stage 5: final_result conditional\n  logic [63:0] final_result;\n  always_comb begin\n    if (|a)\n      final_result = sum2_reg + mul1_reg;\n    else\n      final_result = sum2_reg - mul2_reg;\n  end\n\n  // Register final_result\n  logic [63:0] final_result_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      final_result_reg <= '0;\n    else\n      final_result_reg <= final_result;\n  end\n\n  // Output pipeline stages (3 deep)\n  logic [63:0] pipe1, pipe2, pipe3;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      pipe1 <= '0;\n      pipe2 <= '0;\n      pipe3 <= '0;\n    end else begin\n      pipe1 <= final_result_reg;\n      pipe2 <= pipe1;\n      pipe3 <= pipe2;\n    end\n  end\n\n  // Output register with IOB attribute\n  (* IOB=\"TRUE\" *) logic [63:0] y_reg;\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      y_reg <= '0;\n    else\n      y_reg <= pipe3;\n  end\n\n  assign y = y_reg;\n\nendmodule"
        }
      }
    },
    "risks": [
      "Increased latency (total 9 clock cycles from inputs to output).",
      "Higher resource utilization due to additional registers.",
      "Potential reset‑synchronization issues if downstream logic expects a shorter pipeline."
    ],
    "verification": [
      "Run functional simulation to confirm that pipelined design produces the same results as the original combinational version (accounting for latency).",
      "Perform post‑implementation static timing analysis to verify that the worst negative slack is eliminated and at least 20% positive slack is achieved.",
      "Check that each signal has exactly one driver and that no combinational loops were introduced."
    ]
  },
  "has_sv_artifact": true,
  "model": "gpt-oss-120b",
  "elapsed_sec": 2.365
}
